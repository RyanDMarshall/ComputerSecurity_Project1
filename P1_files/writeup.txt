1.	Using HMAC users password(user = ..) avoids the length extension vulnerability by preventing the simple length extension by turning an unsecure hash algorithm into a keyed hash thus encrypting the secret prefix (the key aka password) then it becomes only vulnerable in MD5 by hashing collision rather than length extension. This is because it is trivial when we can see the authenticator based on the original token constructed from key || m1 to create a new valid token key || m1 || m2 when properly padded2.	The danger associated with compromising code signing by creating a hash collision is that some systems only look at the code signature to determine whether the code they are installing or about to execute is valid. This in essence means that if a code signature can be breached there is no fallback to determine if the code about to run is malicious or not and can lead to complete compromise of a system. In this case hashing using MD5 is not collision resistant and people could forge the signature and run malicious code.3. 	Choosing a sufficiently large public exponent e aka (2^16 + 1) prevents bleichenbachers attack by forcing the wrapping of the signature when the exponent is taking. i.e. the attack only works when we have some signature sig that is then raised to the public exponent e sig^e < n. n being the modulus from the key.